---
title: TCP与UDP
icon: fab fa-markdown
order: 3
category:
  - 使用指南
tag:
  - Markdown
---

<a name="RbfBk"></a>

## TCP 三次握手过程

在讲述[TCP 三次握手](https://so.csdn.net/so/search?q=TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B&spm=1001.2101.3001.7020)，即建立 TCP 连接的过程之前，需要先介绍一下 TCP 协议的包结构。<br />**TCP 协议包结构**：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/1635081/1687069600328-9113c382-f809-4573-83b5-c53d3240af6c.png?x-oss-process=image%2Fresize%2Cw_710%2Climit_0)<br />这里只对涉及到三次握手过程的字段做解释<br />（1） **序号（Sequence number）**<br />我们通过 TCP 协议将数据发送给对方，就比如 hellotcp，这一串字节流，假设被拆分成了三个 TCP 报文段，第一个报文段携带了 hel，第二个报文段携带了 lot，第三个报文段携带了 cp，这三个报文段不一定是按照顺序送到对端的，那么对端收到这三个段是如何确定他们的顺序的呢？此时序号的意义就体现在这里。<br />TCP 连接中，为传送的字节流（数据）中的**每一个字节按顺序编号**。也就是说，在一次 TCP 连接建立的开始，到 TCP 连接的断开，你要传输的所有数据的每一个字节都要编号。这个序号称为[字节序](https://so.csdn.net/so/search?q=%E5%AD%97%E8%8A%82%E5%BA%8F&spm=1001.2101.3001.7020)号。<br />**举个例子**：如果一个 TCP 报文段的序号为 101，它携带了 50 字节的数据，就表示这 50 个字节的数据的字节序号范围是 **[101, 150]**，该报文段携带的第一个字节序号是 101，最后一个字节序号是 150。<br />（2） **确认号（Acknowledge number）**<br />TCP 传输的对端通过回复一个确认号，来表示确认已经接收到了某个 TCP 段。<br />**举个例子**：比如之前发送方发送的序号为 101 的 TCP 段，这个段携带了 50 字节数据，则接收方应当回复的确认号是 151，它表示接收方已经收到了字节序号为 150 之前的数据，现在期望你发送字节序号为 151 以及以后的数据。<br />（3）**ACK**<br />是一个 TCP 协议报文中的标志比特位，如果**置 1**表示这个报文段是一个回复确认报文。

> 注意：为了防止混淆确认号与 ACK，一般确认号写作 ack，而 ACK 就写为 ACK。

4）**SYN**<br />同样是一个 TCP 协议报文中的标志比特位，如果**置 1**表示该报文段用来建立 TCP 连接。<br />介绍完 TCP 协议报文的一些基本字段，我们可以来叙述 TCP 三次握手的过程了。<br />TCP 三次握手流程图：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/1635081/1687069670517-6b139595-cd05-4207-b327-a5247ea40c1f.png#averageHue=%23f1efe7&clientId=ufa8c1f2a-4ed7-4&from=paste&height=826&id=u9938cd8f&originHeight=661&originWidth=809&originalType=binary&ratio=0.800000011920929&rotation=0&showTitle=false&size=60648&status=done&style=none&taskId=u0a6a04b9-d1d6-47fb-aaa4-2d5aee7a910&title=&width=1011.249984931201)<br />（1）第一次握手<br />客户端（Client）向服务器（Server）发送一个 SYN 段(在 TCP 标头中 SYN 位字段为 1 的 TCP/IP 数据包)，该段中也包含一个客户端的初始序列号（Sequence number = x，seq）。<br />（2）第二次握手<br />服务器端返回一个 SYN +ACK 段(在 TCP 标头中 SYN 和 ACK 位字段都为 1 的 TCP/IP 数据包)，该段中包含服务器的初始序列号(Sequence number = y)。同时使 Acknowledgment number = x + 1 来表示确认已收到客户端的 SYN 段(Sequence number = y)。<br />（3）第三次握手<br />客户端给服务器响应一个 ACK 段(在 TCP 标头中 ACK 位字段为 1 的 TCP/IP 数据包)（SYN 已变为 0）, 该段中使 Acknowledgment number = y+ 1 来表示确认已收到服务器的 SYN 段(Sequence number = y)，自己的序列号则是变成 seq=x+1。
<a name="Fmle4"></a>

## 为什么不能两次握手

答：如果只是两次握手，那么按照上述 C/S 模型的流程，第二次握手后服务器端会认为自己已经与客户端建立了连接，假如此时网络出现问题，丢失了第二次握手的报文。那么客户端没有收到应答报文，他认为与服务器端并没有建立连接，那么之后服务器端向客户端发来的消息，客户端并不会接受，而是一直等待应答报文，会形成类似死锁的问题。
<a name="Th0k7"></a>

## TCP 四次挥手过程

1. 客户端发起 fin 位为 1 的 FIN 报文，此时客户端进入 FIN_WAIT_1 状态
2. 服务端接受到 FIN 报文后，发送 ack 应答报文，此时服务端进入 close_wait 状态
3. 客户端接受到 ack 应答报文后，进入 FIN_WAIT_2 状态
4. 服务端处理完数据后，向客户端发送 FIN 报文，此时服务端进入 LAST_ACK 状态
5. 客户端接受到 FIN 报文后，客户端发送应答 ack 报文，进入 TIME_WAIT 阶段
6. 服务端接受到 ack 报文后，断开连接，处于 close 状态
7. 客户端过一段时间后，也就是 2MSL 后，进入 close 状态

![image.png](https://cdn.nlark.com/yuque/0/2023/png/1635081/1687069767126-71d3147e-2b86-4f6e-8270-b18b85133b1d.png)<br />主动关闭连接的，才有 TIME_WAIT 状态
<a name="HoGCV"></a>

## 为什么挥手需要四次？

由于 TCP 的半关闭（half-close）特性，TCP 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。<br />任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。<br />通俗的来说，两次握手就可以释放一端到另一端的 TCP 连接，完全释放连接一共需要四次握手。<br />**举个例子**：A 和 B 打电话，通话即将结束后，A 说 “我没啥要说的了”，B 回答 “我知道了”，于是 A 向 B 的连接释放了。但是 B 可能还会有要说的话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，于是 B 向 A 的连接释放了，这样整个通话就结束了。
<a name="TuPlj"></a>

## 挥手报文丢失会发生什么？

<a name="CSas0"></a>

### 第一次挥手丢失

当客户端调用 close 函数后，就会向服务端发送[FIN](https://so.csdn.net/so/search?q=FIN&spm=1001.2101.3001.7020)报文，试图与服务端断开联系，此时客户端进入 FIN_WAIT_1 状态。<br />如果客户端一直收不到 ack 应答报文的话，就会触发超时重传机制，最大重传次数由 tcp_orphan_retries 参数决定。当超过指定次数时，就不再发送报文，直接进入 close 状态
<a name="yDRFz"></a>

### 第二次挥手丢失

当接受到客户端的 FIN 报文，就会先回应一个 ack 报文，此时服务端进入 close_wait 状态。<br />当 ack 报文丢失时，ack 是不会重传的。服务端的 ack 报文丢失了，客户端就会触发超时重传，直到收到 ack 报文或则到达超时重传次数
<a name="FZ0sO"></a>

### 第三次挥手丢失

当服务端接收到客户端的 fin 报文时，内核会自动回复 ack 应答报文，然后处于 CLOSE_WAIT 状态，他必须等待应用进程调用 close 函数关闭连接。<br />调用 close 函数后，内核就会发出 FIN 报文，进入 LAST_ACK 状态，等待客户端返回 ack 来确认关闭连接。<br />如果服务端没有收到 ack，则会跟客户端重传 FIN 报文一样
<a name="gnkti"></a>

### 第四次挥手丢失

当客户端接收到服务端发来的 FIN 报文后，就会回应 ack 应答报文，进入[TIME_WAIT](https://so.csdn.net/so/search?q=TIME_WAIT&spm=1001.2101.3001.7020)状态。<br />服务端没有收到 ack 报文之前，还是处于 LAST_ACK 状态<br />如果服务端没有收到 ack 报文的话，服务端就会重发 FIN 报文，重发次数仍然由 tcp_orphan_retries 参数控制
<a name="DFeSM"></a>

## 为什么需要 TIME_WAIT 状态

主要是两方面：

- 防止错误接收历史报文
- 保证双方能够正常关闭
  <a name="PX2XA"></a>

### 防止错误接收历史报文

tcp 序列号可能会发生绕回问题，这就意味着无法通过 tcp 序列号来判断是不是历史报文。(**时间戳可以解决是不是历史报文问题，时间戳还可以精确计算 RTT**)<br />假设没有 TIME_WAIT 状态，那么在关闭连接前有个报文被延迟了。关闭后，又重新建立了相同四元组的连接，此时前一个被延迟的数据包到达了(没有到达最大生存时间)，并且正好在接收窗口内，那么服务端就会错误接收，使得数据混乱。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/1635081/1687069782547-0501f2a7-3df1-4105-b4c6-fca1782648c4.png?x-oss-process=image%2Fresize%2Cw_937%2Climit_0)<br />因此有了这个 TIME_WAIT 字段，可以保证两边的历史数据都被丢弃了，以后的数据包都是新建立连接的。
<a name="Xb1Dp"></a>

### 保证双方能够正常关闭

如果没有 TIME_WAIT 状态的话，客户端最后一次发送 ack 应答报文后就进入了 close 阶段。如果服务端没有收到 ack 报文的话，就会重传 FIN 报文，而此时客户端已经 close 了，就会返回一个 RST 错误报文。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/1635081/1687069782564-215c331e-b197-4c0f-add1-7a40b23bccc9.png?x-oss-process=image%2Fresize%2Cw_937%2Climit_0)<br />而有了 TIME_WAIT 状态的话，客户端并不会着急关闭，而是等待了 2MSL 再关闭，这样的话就算重传的 fin 报文也能正确响应，保证了服务端的正确关闭<br />这里客户端重新接收到了重发的 fin 报文，time_wait 就会重置（也是为了重复报文的消失，不然的话 ack 报文可能就会到下一次连接中了），相当于可以重传多次 fin 报文，直到 fin 报文上限
<a name="aSdbF"></a>

## 为什么 TIME_WAIT 等待时间是 2MSL？

MSL 是报文的最大生存时间,超过这个时间，报文就将丢弃。<br />因为 tcp 是基于 ip 协议的，ip 头中有一个 ttl 字段，表示 ip 数据包可以经过的最大路由数。每经过一个节点时，就减一，减为 0 则丢弃报文。<br />MSL 和 TTL 的区别：MSL 的单位是时间，而 TTL 的单位则是路由跳数。所以 MSL 应该大于等于 TTL 的时间，确保报文已经消亡<br />TIME_WAIT 比较合理的解释是：确保对方能够收到最后一个 ack 报文，如果服务端没有收到最后的 ack 报文，就会触发超时重传 fin 报文，从客户端发送 ack 报文到接到到服务端重传的 fin 报文，一去一来，最晚要 2msl<br />为什么不是 1MSL？？

- 因为 1MSL 可能导致历史数据还没有消亡，导致被后面相同的四元组接收。比如服务端重发的 fin 报文
- 客户端发送的 ack 报文不允许丢失，不然重发的 fin 报文不能抵达客户端，导致服务端 RST 关闭

为什么不是 4MSL 或 8MSL

- 因为如果客户端发送的 ack 报文丢失，服务端重发的 fin 报文也丢失了，那么 2MSL 就不起作用了。那么需要给它设置更长时间？？我们设想在一个丢包率为 1%的糟糕网络中，两次连续丢包的概率为万分之一，忽略它显然给解决它更具有实际意义
  <a name="hBGlR"></a>

## TIME_WAIT 过多有什么危害？

- 服务端受内存资源占用<br />当服务端有过多的的 TCP 连接时，虽然理论上可以建立很多连接，因为一个服务端只监听一个端口，不会导致端口资源受限。但是 tcp 连接需要占用系统资源，比如 cpu 资源，文件描述符，线程资源等等
- 客户端受端口资源的占用<br />一个 tcp 占用一个发起连接方的一个本地端口，如果 tcp 连接过多，则会导致端口资源不足，无法建立新连接
  <a name="XGeA0"></a>

## 如何优化 TIME_WAIT？？

- 打开 net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_timestamps 选项<br />net.ipv4.tcp_tw_reuse 之只能用于客户端，当有连接时，客户端会随机找一个 time_wait 状态超过 1s 的连接给新连接复用。<br />net.ipv4.tcp_timestamps 开启时间戳，可以保证历史连接不会被下一个相同的四元组接收
- net.ipv4.tcp_max_tw_buckets<br />这个值默认为 18000，当系统处于 time_wait 状态的连接大于这个值时，后面的连接状态就会被重置，不会产生新的 time_wait 状态
- 程序中使用 SO_LINGER<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/1635081/1687069782546-a3c9eace-5a1d-458e-8e49-58a64aa1de97.png#averageHue=%23292d36&clientId=ufa8c1f2a-4ed7-4&from=paste&id=u018f91d9&originHeight=134&originWidth=802&originalType=url&ratio=0.800000011920929&rotation=0&showTitle=false&status=done&style=none&taskId=u522b389a-c631-4b06-90a5-657b2078d22&title=)<br />当 l_onoff 为非 0，l_linger 为 0 时，调用 close 关闭连接时就会直接发送 RST 报文，直接跳过四次挥手阶段

如果服务端要尽量避免 TIME_WAIT 状态的连接，就尽量不要让服务端来断开连接，承受 time_wait 状态，而是尽量让我们发布各地的客户端来断开连接<br />《UNIX 网络编程》一书中却说道：TIME_WAIT 是我们的朋友，它是有助于我们的，不要试图避免这个状态，而是应该弄清楚它。
<a name="CyHoJ"></a>

## 如果已经建立了连接，但是另一端突然出现故障，会发生什么？

TCP 有一个保活机制，当一端时间相互直接没有发送数据时，就会触发保活机制。即每隔一段时间都发送一次探测报文给对方，如果几次都不回应的话，就会认为对方已经死亡了，那么就会断开连接。<br />如果需要使用保活机制，那么需要在 soket 接口设置 so_keepliive 才能生效，如果没有设置，则不可以生效<br />TCP 的检测时间有点长，我们可以在应用层实现一个心跳机制。<br />web 服务一般都会提供 time_keeplive 参数，用来指定 http 长连接超时时间。
<a name="ZR0HE"></a>

## UDP

UDP 协议全称是用户数据报协议，在网络中它与 TCP 协议一样用于处理数据包，是一种无连接的协议。在 OSI 模型中，在第四层——传输层，处于 IP 协议的上一层。UDP 有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。<br />它有以下几个特点：<br />1. 面向无连接<br />首先 UDP 是不需要和 TCP 一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。<br />具体来说就是：

- 在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了
- 在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作

2. 有单播，多播，广播的功能<br />UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。<br />3. UDP 是面向报文的<br />发送方的 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文<br />4. 不可靠性<br />首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。<br />并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。<br />再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。<br />5. 头部开销小，传输数据报文时是很高效的。
   <a name="VM9Gk"></a>

## TCP 与 UDP 区别

![image.png](https://cdn.nlark.com/yuque/0/2023/png/1635081/1687069913161-763e66d7-88c2-47b9-85f5-fc86d4f884a5.png?x-oss-process=image%2Fresize%2Cw_937%2Climit_0)
<a name="gwwe6"></a>

## TCP 和 UDP 对应的协议

<a name="IsY63"></a>

### 一.UDP 对应的协议

1.DNS：用于域名解析服务，将域名地址转换为 IP 地址，使用 53 号端口。<br />2.[SNMP](https://so.csdn.net/so/search?q=SNMP&spm=1001.2101.3001.7020)：简单网络管理协议，使用 161 号端口，是用来管理网络设备。由于网络设备过多，无连接的服务就体现出优势。<br />3.TFTP：简单文件传输协议，该协议在端口 69 号使用 UDP 服务。
<a name="nXPaa"></a>

### 二.TCP 对应的协议

1.FTP：定义了文件传输协议，使用 21 号端口。<br />2.Telnet：用于远程登录的端口，其使用 23 号端口，用户可以以自己的身份远程连接到计算机上，可提供基于 DOS 模式下的通信服务。<br />3.[SMTP](https://so.csdn.net/so/search?q=SMTP&spm=1001.2101.3001.7020)：邮件传送协议，用于发送邮件。其使用 25 号端口。<br />3.POP3：其与 SMTP 对应，POP3 用于接收邮件。使用了 110 端口。<br />4.HTTP：从 Web 服务器传输超文本到本地浏览器的传送协议，端口是 80 号。
<a name="ttcCN"></a>

## TCP 粘包与拆包问题及解决方案

在 RPC 框架中，TCP 粘包和拆包问题是必须解决一个问题，因为 RPC 框架中，各个[微服务](https://so.csdn.net/so/search?q=%E5%BE%AE%E6%9C%8D%E5%8A%A1&spm=1001.2101.3001.7020)相互之间都是维系了一个 TCP 长连接，比如 dubbo 就是一个全双工的长连接。由于微服务往对方发送信息的时候，所有的请求都是使用的同一个连接，这样就会产生粘包和拆包的问题。<br />何时发生：

- （1）长连接，数据发送频繁，接收不及时
- （2）数据结构不一致

粘包与拆包：<br />TCP 在接受数据的时候，有一个滑动窗口来控制接受数据的大小，这个滑动窗口你就可以理解为一个缓冲区的大小。缓冲区满了就会把数据发送。数据包的大小是不固定的，有时候比缓冲区大有时候小。如果一次请求发送的数据量比较小，没达到缓冲区大小，TCP 则会将多个请求合并为同一个请求进行发送，这就形成了粘包问题；如果一次请求发送的数据量比较大，超过了缓冲区大小，TCP 就会将其拆分为多次发送，这就是拆包，也就是将一个大的包拆分为多个小包进行发送。<br />常见解决方案：<br />对于粘包和拆包问题，常见的解决方案有四种：

- 客户端在发送数据包的时候，每个包都固定长度，比如 1024 个字节大小，如果客户端发送的数据长度不足 1024 个字节，则通过补充空格的方式补全到指定长度；
- 客户端在每个包的末尾使用固定的分隔符，例如\r\n，如果一个包被拆分了，则等待下一个包发送过来之后找到其中的\r\n，然后对其拆分后的头部部分与前一个包的剩余部分进行合并，这样就得到了一个完整的包；
- 将消息分为头部和消息体，在头部中保存有当前整个消息的长度，只有在读取到足够长度的消息之后才算是读到了一个完整的消息；
- 通过自定义协议进行粘包和拆包的处理。

Netty 提供的粘包拆包解决方案<br />1、FixedLengthFrameDecoder<br />对于使用固定长度的粘包和拆包场景，可以使用 FixedLengthFrameDecoder，该解码器会每次读取固定长度的消息，如果当前读取到的消息不足指定长度，那么就会等待下一个消息到达后进行补足。<br />2、LineBasedFrameDecoder 与 DelimiterBasedFrameDecoder<br />对于通过分隔符进行粘包和拆包问题的处理，Netty 提供了两个编解码的类，LineBasedFrameDecoder 和 DelimiterBasedFrameDecoder。这里 LineBasedFrameDecoder 的作用主要是通过换行符，即\n 或者\r\n 对数据进行处理；而 DelimiterBasedFrameDecoder 的作用则是通过用户指定的分隔符对数据进行粘包和拆包处理。<br />3、LengthFieldBasedFrameDecoder 与 LengthFieldPrepender<br />这里 LengthFieldBasedFrameDecoder 与 LengthFieldPrepender 需要配合起来使用，其实本质上来讲，这两者一个是解码，一个是编码的关系。它们处理粘拆包的主要思想是在生成的数据包中添加一个长度字段，用于记录当前数据包的长度。<br />4、自定义粘包与拆包器<br />对于粘包与拆包问题，其实前面三种基本上已经能够满足大多数情形了，但是对于一些更加复杂的协议，可能有一些定制化的需求。对于这些场景，其实本质上，我们也不需要手动从头开始写一份粘包与拆包处理器，而是通过继承 LengthFieldBasedFrameDecoder 和 LengthFieldPrepender 来实现粘包和拆包的处理。
<a name="EzJRt"></a>

## Nagle 算法

TCP 是基于流的传输协议，在 Rlogin 和 Telnet 传输中会出现只有一个字节数据的 TCP 数据包。而一个 TCP 数据包的首部加上 IP 首部就有 40 个字节，很显然发这样的数据包划不来。为了减少这样的数据包，有人提出了 Nagle 算法。<br />Nagle 算法简单讲就是，等待服务器应答包到达后，再发送下一个数据包。数据在发送端被缓存，**如果缓存到达指定大小就将其发送**，或者上一个数据的应答包到达，将缓存区一次性全部发送。<br />Nagle 算法是从发送端角度考虑减少了数据包的个数，时延应答从接收端角度考虑减少了数据包的个数。<br />**注意**：我以前一直理解为只有上一个数据的应答包到达时才发送数据，但有一个前提条件是发送缓冲区中的数据大小不足一个 MSS 时，当数据超过一个 MSS 时，直接发送报文段。
<a name="aYd1J"></a>

## 滑动窗口(流量控制)

1)TCP 滑动窗口分为接受窗口，发送窗口<br />滑动窗口协议是传输层进行流控的一种措施，接收方通过通告发送方自己的窗口大小，从而控制发送方的发送速度，从而达到防止发送方发送速度过快而导致自己被淹没的目的。<br />对 ACK 的再认识，ack 通常被理解为收到数据后给出的一个确认 ACK，ACK 包含两个非常重要的信息：

- 一是期望接收到的下一字节的序号 n，该 n 代表接收方已经接收到了前 n-1 字节数据，此时如果接收方收到第 n+1 字节数据而不是第 n 字节数据，接收方是不会发送序号为 n+2 的 ACK 的。举个例子，假如接收端收到 1-1024 字节，它会发送一个确认号为 1025 的 ACK,但是接下来收到的是 2049-3072，它是不会发送确认号为 3072 的 ACK,而依旧发送 1025 的 ACK。
- 二是当前的窗口大小 m，如此发送方在接收到 ACK 包含的这两个数据后就可以计算出还可以发送多少字节的数据给对方，假定当前发送方已发送到第 x 字节，则可以发送的字节数就是 y=m-(x-n).

这就是滑动窗口控制流量的基本原理<br />**重点：发送方根据收到 ACK 当中的期望收到的下一个字节的序号 n 以及窗口 m，还有当前已经发送的字节序号 x，算出还可以发送的字节数。**<br />1）对于 TCP 会话的发送方，任何时候在其发送缓存内的数据都可以分为 4 类，“已经发送并得到对端 ACK 的”，“已经发送但还未收到对端 ACK 的”，“未发送但对端允许发送的”，“未发送且对端不允许发送”。“已经发送但还未收到对端 ACK 的”和“未发送但对端允许发送的”这两部分数据称之为发送窗口。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/1635081/1687071233960-972239f7-ed1d-453c-a418-759882bd5066.png?x-oss-process=image%2Fresize%2Cw_664%2Climit_0)<br />当收到接收方新的 ACK 对于发送窗口中后续字节的确认是，窗口滑动，滑动原理如下图。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/1635081/1687071233894-c8b112d7-aed7-44d2-82aa-3f84ce7c6f7a.png?x-oss-process=image%2Fresize%2Cw_667%2Climit_0)<br />当收到 ACK=36 时窗口滑动。2）对于 TCP 的接收方，在某一时刻在它的接收缓存内存在 3 种。“已接收”，“未接收准备接收”，“未接收并未准备接收”（由于 ACK 直接由 TCP 协议栈回复，默认无应用延迟，不存在“已接收未回复 ACK”）。其中“未接收准备接收”称之为接收窗口。
<a name="t3VE5"></a>

### 发送窗口与接收窗口关系

TCP 是双工的协议，会话的双方都可以同时接收、发送数据。TCP 会话的双方都各自维护一个“发送窗口”和一个“接收窗口”。其中各自的“接收窗口”大小取决于应用、系统、硬件的限制（TCP 传输速率不能大于应用的数据处理速率）。各自的“发送窗口”则要求取决于对端通告的“接收窗口”，要求相同。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/1635081/1687071233984-ff2c4070-cbc5-4985-ad1b-eaf4487c4d8b.png?x-oss-process=image%2Fresize%2Cw_675%2Climit_0)
<a name="X5OU5"></a>

### 滑动窗口实现面向流的可靠性

1. 最基本的传输可靠性来源于“确认重传”机制。
2. TCP 的滑动窗口的可靠性也是建立在“确认重传”基础上的。
3. 发送窗口只有收到对端对于本段发送窗口内字节的 ACK 确认，才会移动发送窗口的左边界。
4. 接收窗口只有在前面所有的段都确认的情况下才会移动左边界。当在前面还有字节未接收但收到后面字节的情况下，窗口不会移动，并不对后续字节确认。以此确保对端会对这些数据重传。
   <a name="L4aR9"></a>

## 拥塞控制

TCP 不仅可以可以控制端到端的数据传输，还可以对网络上的传输进行监控。这使得 TCP 非常强大智能，它会根据网络情况来调整自己的收发速度。网络顺畅时就可以发的快，拥塞时就发的相对慢一些。拥塞控制算法主要有四种：慢启动，拥塞避免，快速重传和快速恢复。
