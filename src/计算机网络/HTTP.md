---
title: HTTP
icon: fab fa-markdown
order: 3
category:
  - 使用指南
tag:
  - Markdown
---

<a name="VWJuy"></a>

## http 请求方法

![image.png](https://cdn.nlark.com/yuque/0/2023/png/1635081/1687064916968-ba541a86-c8a8-4c39-a041-149f5a6b2b65.png?x-oss-process=image%2Fresize%2Cw_937%2Climit_0)
<a name="VuDb8"></a>

## http 请求过程

以下是 HTTP 请求/响应的步骤：

- 1、客户端连接到 Web 服务器一个 HTTP 客户端，通常是浏览器，与 Web 服务器的 HTTP 端口（默认为 80）建立一个 TCP 套接字连接。例如，http://www.oakcms.cn。
- 2、发送 HTTP 请求通过 TCP 套接字，客户端向 Web 服务器发送一个文本的请求报文，一个请求报文由
- 请求行、请求头部、空行和请求数据 4 部分组成。
- 3、服务器接受请求并返回 HTTP 响应 Web 服务器解析请求，定位请求资源。服务器将资源复本写到 TCP 套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据 4 部分组成。
- 4、释放连接 TCP 连接若 connection 模式为 close，则服务器主动关闭 TCP 连接，客户端被动关闭连接，释放 TCP 连接;若 connection 模式为 keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;
- 5、客户端浏览器解析 HTML 内容客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的 HTML 文档和文档的字符集。客户端浏览器读取响应数据 HTML，根据 HTML 的语法对其进行格式化，并在浏览器窗口中显示。
  <a name="kPrB2"></a>

## get 和 post 请求区别

1、post 请求更安全；post 请求不会作为 url 的一部分，不会被缓存、保存在服务器日志、以及浏览器浏览记录中，get 请求的是静态资源，则会缓存，如果是数据，则不会缓存。<br />2、post 请求发送的数据更大，get 请求有 url 长度限制。<br />3、post 请求能发送更多的数据类型，get 请求只能发送 ASCII 字符。<br />4、传参方式不同。<br />5、get 产生一个 TCP 数据包；post 产生两个。
<a name="iWCfH"></a>

## http 状态码

<a name="D4Mc0"></a>

### 1xx

100：（继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。<br />101：（切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。<br />102：由 WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。
<a name="afz0V"></a>

### 2XX

200：（成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。<br />201：（已创建） 请求成功并且服务器创建了新的资源。<br />202：（已接受） 服务器已接受请求，但尚未处理。<br />203：（非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。<br />204：（无内容） 服务器成功处理了请求，但没有返回任何内容。<br />205：（重置内容） 服务器成功处理了请求，但没有返回任何内容。<br />206：（部分内容） 服务器成功处理了部分 GET 请求。<br />208：（已经报告）一个 DAV 的绑定成员被前一个请求枚举，并且没有被再一次包括。<br />226：（IM Used）服务器已经满足了请求所要的资源，并且响应是一个或者多个实例操作应用于当前实例的结果。
<a name="mmaCp"></a>

### 3XX

300：（多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。<br />301：（永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。<br />302：（临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。<br />303：（查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。<br />304：（未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。<br />305：（使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。<br />307：（临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。<br />308：（永久转移）这个请求和以后的请求都应该被另一个 URI 地址重新发送。307、308 和 302、301 有相同的表现，但是不允许 HTTP 方法改变。例如，请求表单到一个永久转移的资源将会继续顺利地执行。
<a name="CldZG"></a>

### 4XX

400:（错误请求) 服务器不理解请求的语法。<br />401：(未授权) 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。<br />402：该状态码是为了将来可能的需求而预留的。<br />403：（禁止) 服务器拒绝请求。<br />404：（未找到) 服务器找不到请求的网页。<br />405：（方法禁用) 禁用请求中指定的方法。<br />406：（不接受) 无法使用请求的内容特性响应请求的网页。<br />407：（需要代理授权) 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。<br />408：（请求超时) 服务器等候请求时发生超时。<br />409：（冲突) 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。<br />410：（已删除) 如果请求的资源已永久删除，服务器就会返回此响应。<br />411：（需要有效长度) 服务器不接受不含有效内容长度标头字段的请求。<br />412：（未满足前提条件) 服务器未满足请求者在请求中设置的其中一个前提条件。<br />413：（请求实体过大) 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。<br />414：（请求的 URI 过长) 请求的 URI（通常为网址）过长，服务器无法处理。<br />415：（不支持的媒体类型) 请求的格式不受请求页面的支持。<br />416：（请求范围不符合要求) 如果页面无法提供请求的范围，则服务器会返回此状态代码。<br />417：（未满足期望值) 服务器未满足"期望"请求标头字段的要求。<br />418：（我是一个茶壶）这个代码是在 1998 年作为传统的 IETF April Fools‘ jokes 被定义的在 RFC2324，超文本咖啡罐控制协议，但是并没有被实际的 HTTP 服务器实现。RFC 指定了这个代码应该是由茶罐返回给速溶咖啡。<br />419：（认证超时）并不是 HTTP 标注的一部分，419 认证超时表示以前的有效证明已经失效了。同时也被用于 401 未认证的替代选择为了从其它被拒绝访问的已认证客户端中指定服务器的资源。<br />420：（方法失效）不是 HTTP 的标准，但是被 Spring 定义在 HTTP 状态类中当方法失时使用。这个状态码已经不推荐在 Spring 中使用。<br />420：（提高你的耐心）也不是 HTTP 标准的一部分，但是被版本 1 的 Twitter 搜索和趋势 APi 返回当客户端的速率被限制的时候。其它的服务提供商可能会使用 429 太多的请求响应码来代替。<br />421：从当前客户端所在的 IP 地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的 IP 地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。<br />422：请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）423 Locked<br />当前资源被锁定。（RFC 4918 WebDAV）<br />424：由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。（RFC 4918 WebDAV）<br />425：在 WebDav Advanced Collections 草案中定义，但是未出现在《WebDAV 顺序集协议》（RFC 3658）中。<br />426：客户端应当切换到 TLS/1.0。（RFC 2817）<br />428：(需要前置条件)原始服务器需要有条件的请求。当客户端 GET 一个资源的状态的时候，同时又 PUT 回给服务器，与此同时第三方修改状态到服务器上的时候，为了避免丢失更新的问题发生将会导致冲突。<br />429：（过多请求）用户已经发送了太多的请求在指定的时间里。用于限制速率。<br />431：（请求头部字段太大）服务器由于一个单独的请求头部字段或者是全部的字段太大而不愿意处理请求。<br />440：（登陆超时（微软））一个微软的扩展，意味着你的会话已经超时。<br />444：（无响应）被使用在 Nginx 的日志中表明服务器没有返回信息给客户端并且关闭了连接（在威慑恶意软件的时候比较有用）。<br />449：（重试（微软））一个微软的扩展。请求应该在执行适当的动作之后被重试。<br />450：（被 Windows 家长控制阻塞（微软））一个微软的扩展。这个错误是当 Windows 家长控制打开并且阻塞指定网页的访问的时候被指定。<br />451：（由于法律原因而无效（因特网草稿））被定义在因特网草稿“一个新的 HTTP 状态码用于法律限制的资源”。被用于当资源的访问由于法律原因被禁止的时候。例如检查制度或者是政府强制要求禁止访问。一个例子是 1953 年 dystopian 的小说 Fahrenheit 451 就是一个非法的资源。<br />451：（重定向（微软））被用在 Exchange ActiveSync 中如果一个更有效的服务器能够被使用或者是服务器不能访问用户的邮箱。客户端会假定重新执行 HTTP 自动发现协议去寻找更适合的服务器。<br />494：（请求头太大（Nginx））Nginx 内置代码和 431 类似，但是是被更早地引入在版本 0.9.4（在 2011 年 1 月 21 日）。<br />495：（证书错误（Nginx））Nginx 内置的代码，当使用 SSL 客户端证书的时候错误会出现为了在日志错误中区分它和 4XX 和一个错误页面的重定向。。<br />496：（没有证书（Nginx））Nginx 内置的代码，当客户端不能提供证书在日志中分辨 4XX 和一个错误页面的重定向。<br />497：（HTTP 到 HTTPS（Nginx））Nginx 内置的代码，被用于原始的 HTTP 的请求发送给 HTTPS 端口去分辨 4XX 在日志中和一个错误页面的重定向。<br />498：（令牌超时或失效（Esri））由 ArcGIS for Server 返回。这个代码意味着令牌的超时或者是失效。<br />499：（客户端关闭请求（Nginx））被用在 Nginx 日志去表明一个连接已经被客户端关闭当服务器仍然正在处理它的请求，是的服务器无法返货状态码。<br />499：（需要令牌（Esri））由 ArcGIS for Server 返回。意味着需要一个令牌（如果没有令牌被提交）。
<a name="TN9oh"></a>

### 5XX

500：（服务器内部错误） 服务器遇到错误，无法完成请求。<br />501：（尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。<br />502：（错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。<br />503：（服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。<br />504：（网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。<br />505：（HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。<br />506：由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。<br />507：服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV (RFC 4918)<br />509：服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。<br />510：获取资源所需要的策略并没有没满足。（RFC 2774）。<br />508：（发现环路）服务器发现了一个无限的循环档处理请求的时候。<br />511：（需要网络授权）客户端需要授权去火的网络的访问权限。一般用于代理交互中被用来进行网络的访问控制。<br />520：（未知错误）这个状态码也没有被指定在任何 RFC 中，并且只会被一些服务器返回，例如微软的 Azure 和 CloudFlare 服务器:”520 错误。本质上是一个捕获全部的响应当原始服务器返回一些未知的或者一些不能被忍受或者被解释的(协议违反或者空响应)”。<br />598：（网络读取超时异常(未知)）这个状态码也没有在任何 RFC 中指定，但是被用在微软的 HTTP 代理中去标注一个网络读取超时在一个客户端之前的代理的后面。<br />599：（网络连接超时异常(未知)）这个状态码也没有在任何 RFC 中指定，但是被用在微软的 HTTP 代理中去标注一个网络连接超时在一个客户端之前的代理的后面。
<a name="QiFzL"></a>

## HTTP 协议与 TCP/IP 协议的关系

HTTP 的长连接和短连接本质上是 TCP 长连接和短连接。HTTP 属于应用层协议，在传输层使用 TCP 协议，在网络层使用 IP 协议。 IP 协议主要解决网络路由和寻址问题，TCP 协议主要解决如何在 IP 层之上可靠地传递数据包，使得网络上接收端收到发送端所发出的所有包，并且顺序与发送顺序一致。TCP 协议是可靠的、面向连接的。

<a name="iUhkm"></a>

## 如何理解 HTTP 协议是无状态的

HTTP 协议是无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和上一次打开这个服务器上的网页之间没有任何联系。HTTP 是一个无状态的面向连接的协议，无状态不代表 HTTP 不能保持 TCP 连接，更不能代表 HTTP 使用的是 UDP 协议（无连接）。

<a name="sF2Kd"></a>

## 什么是长连接、短连接

在 HTTP/1.0 中默认使用短连接。也就是说，客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源（如 JavaScript 文件、图像文件、CSS 文件等），每遇到这样一个 Web 资源，浏览器就会重新建立一个 HTTP 会话。<br />而从 HTTP/1.1 起，默认使用长连接，用以保持连接特性。使用长连接的 HTTP 协议，会在响应头加入这行代码：

```makefile
Connection:keep-alive
```

在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如 Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。<br />HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接。
<a name="w27pX"></a>

## HTTP1.0 和 HTTP1.1 的一些区别

HTTP1.0 最早在网页中使用是在 1996 年，那个时候只是使用一些较为简单的网页上和网络请求上，而 HTTP1.1 则在 1999 年才开始广泛应用于现在的各大浏览器网络请求中，同时 HTTP1.1 也是当前使用最为广泛的 HTTP 协议。 主要区别主要体现在：

1. 缓存处理，在 HTTP1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。
2. 带宽优化及网络连接的使用，HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
3. 错误通知的管理，在 HTTP1.1 中新增了 24 个错误状态响应码，如 409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。
4. Host 头处理，在 HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个 IP 地址。HTTP1.1 的请求消息和响应消息都应支持 Host 头域，且请求消息中如果没有 Host 头域会报告一个错误（400 Bad Request）。
5. 长连接，HTTP 1.1 支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟，在 HTTP1.1 中默认开启 Connection： keep-alive，一定程度上弥补了 HTTP1.0 每次请求都要创建连接的缺点。
   <a name="XHLtj"></a>

## HTTPS 与 HTTP 的一些区别

- HTTPS 协议需要到 CA 申请证书，一般免费证书很少，需要交费。
- HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，HTTPS 运行在 SSL/TLS 之上，SSL/TLS 运行在 TCP 之上，所有传输的内容都经过加密的。
- HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。
- HTTPS 可以有效的防止运营商劫持，解决了防劫持的一个大问题。

![image.png](https://cdn.nlark.com/yuque/0/2023/png/1635081/1687066382973-5a990537-215b-478e-8ac4-1e65c5daf139.png#averageHue=%23f9f9f9&clientId=ub956d6fd-3a0a-4&from=paste&id=u931380fe&originHeight=280&originWidth=726&originalType=url&ratio=0.800000011920929&rotation=0&showTitle=false&status=done&style=none&taskId=u936b9458-fb29-4da9-a5bf-801d6439681&title=)
<a name="YMEZg"></a>

## SPDY：HTTP1.x 的优化

2012 年 google 如一声惊雷提出了 SPDY 的方案，优化了 HTTP1.X 的请求延迟，解决了 HTTP1.X 的安全性，具体如下：

1. 降低延迟，针对 HTTP 高延迟的问题，SPDY 优雅的采取了多路复用（multiplexing）。多路复用通过多个请求 stream 共享一个 tcp 连接的方式，解决了 HOL blocking 的问题，降低了延迟同时提高了带宽的利用率。
2. 请求优先级（request prioritization）。多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY 允许给每个 request 设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的 html 内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。
3. header 压缩。前面提到 HTTP1.x 的 header 很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。
4. 基于 HTTPS 的加密协议传输，大大提高了传输数据的可靠性。
5. 服务端推送（server push），采用了 SPDY 的网页，例如我的网页有一个 sytle.css 的请求，在客户端收到 sytle.css 数据的同时，服务端会将 sytle.js 的文件推送给客户端，当客户端再次尝试获取 sytle.js 时就可以直接从缓存中获取到，不用再发请求了。SPDY 构成图：

![image.png](https://cdn.nlark.com/yuque/0/2023/png/1635081/1687066443159-c0e145dc-ad6d-4144-9727-8f0fd0828216.png#averageHue=%23fcfcfc&clientId=ub956d6fd-3a0a-4&from=paste&id=u766a92ee&originHeight=335&originWidth=336&originalType=url&ratio=0.800000011920929&rotation=0&showTitle=false&status=done&style=none&taskId=uae7adc7f-ca54-4e8f-8e06-6dfe4f2afca&title=)

SPDY 位于 HTTP 之下，TCP 和 SSL 之上，这样可以轻松兼容老版本的 HTTP 协议(将 HTTP1.x 的内容封装成一种新的 frame 格式)，同时可以使用已有的 SSL 功能。
<a name="FkoG3"></a>

## HTTP2.0 性能惊人

HTTP/2: the Future of the Internet https://link.zhihu.com/?target=https://http2.akamai.com/demo 是 Akamai 公司建立的一个官方的演示，用以说明 HTTP/2 相比于之前的 HTTP/1.1 在性能上的大幅度提升。 同时请求 379 张图片，从 Load time 的对比可以看出 HTTP/2 在速度上的优势。

![image.png](https://cdn.nlark.com/yuque/0/2023/jpeg/1635081/1687066443174-ff6b7c3e-3364-43a0-be08-be3f871ea1a0.jpeg#averageHue=%234e5334&clientId=ub956d6fd-3a0a-4&from=paste&id=u0ab6004d&originHeight=477&originWidth=745&originalType=url&ratio=0.800000011920929&rotation=0&showTitle=false&status=done&style=none&taskId=ueeb5cf3e-0167-4b37-a60b-79c78dc0908&title=)

<a name="Bxku4"></a>

## HTTP2.0：SPDY 的升级版

HTTP2.0 可以说是 SPDY 的升级版（其实原本也是基于 SPDY 设计的），但是，HTTP2.0 跟 SPDY 仍有不同的地方，如下：<br />HTTP2.0 和 SPDY 的区别：<br />HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS<br />HTTP2.0 消息头的压缩算法采用 HPACK http://http2.github.io/http2-spec/compression.html，而非 SPDY 采用的 DEFLATE http://zh.wikipedia.org/wiki/DEFLATE
<a name="aPoJl"></a>

## HTTP2.0 和 HTTP1.X 相比的新特性

- 新的二进制格式（Binary Format），HTTP1.x 的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认 0 和 1 的组合。基于这种考虑 HTTP2.0 的协议解析决定采用二进制格式，实现方便且健壮。
- 多路复用（MultiPlexing），即连接共享，即每一个 request 都是是用作连接共享机制的。一个 request 对应一个 id，这样一个连接上可以有多个 request，每个连接的 request 可以随机的混杂在一起，接收方可以根据 request 的 id 将 request 再归属到各自不同的服务端请求里面。
- header 压缩，如上文中所言，对前面提到过 HTTP1.x 的 header 带有大量信息，而且每次都要重复发送，HTTP2.0 使用 encoder 来减少需要传输的 header 大小，通讯双方各自 cache 一份 header fields 表，既避免了重复 header 的传输，又减小了需要传输的大小。
- 服务端推送（server push），同 SPDY 一样，HTTP2.0 也具有 server push 功能。
  <a name="m1HGh"></a>

## HTTP2.0 的升级改造

- 前文说了 HTTP2.0 其实可以支持非 HTTPS 的，但是现在主流的浏览器像 chrome，firefox 表示还是只支持基于 TLS 部署的 HTTP2.0 协议，所以要想升级成 HTTP2.0 还是先升级 HTTPS 为好。
- 当你的网站已经升级 HTTPS 之后，那么升级 HTTP2.0 就简单很多，如果你使用 NGINX，只要在配置文件中启动相应的协议就可以了，可以参考 NGINX 白皮书，NGINX 配置 HTTP2.0 官方指南 https://www.nginx.com/blog/nginx-1-9-5/。
- 使用了 HTTP2.0 那么，原本的 HTTP1.x 怎么办，这个问题其实不用担心，HTTP2.0 完全兼容 HTTP1.x 的语义，对于不支持 HTTP2.0 的浏览器，NGINX 会自动向下兼容的。

<a name="OhKyU"></a>

## HTTP2.0 的多路复用和 HTTP1.X 中的长连接复用有什么区别？

- HTTP/1.\* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；
- HTTP/1.1 Pipeling 解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；
- HTTP/2 多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；<br />具体如图：

![image.png](https://cdn.nlark.com/yuque/0/2023/jpeg/1635081/1687066443253-d278de8d-60c4-491c-b808-c60b00c7d65e.jpeg#averageHue=%23f7f7f7&clientId=ub956d6fd-3a0a-4&from=paste&id=uc6740289&originHeight=745&originWidth=755&originalType=url&ratio=0.800000011920929&rotation=0&showTitle=false&status=done&style=none&taskId=u1528a744-de88-46cd-950c-ee3bb676e6d&title=)

服务器推送到底是什么？<br />服务端推送能把客户端所需要的资源伴随着 index.html 一起发送到客户端，省去了客户端重复请求的步骤。正因为没有发起请求，建立连接等操作，所以静态资源通过服务端推送的方式可以极大地提升速度。具体如下：

- 普通的客户端请求过程：

![image.png](https://cdn.nlark.com/yuque/0/2023/jpeg/1635081/1687066443233-975c58e8-60b1-4a9f-be97-5c2c794288f4.jpeg#averageHue=%23fafafa&clientId=ub956d6fd-3a0a-4&from=paste&id=ua6ef6154&originHeight=630&originWidth=726&originalType=url&ratio=0.800000011920929&rotation=0&showTitle=false&status=done&style=none&taskId=u17b12f45-0130-4613-a127-720765295ff&title=)

- 服务端推送的过程：

![image.png](https://cdn.nlark.com/yuque/0/2023/png/1635081/1687066443179-4d4e2e64-4d66-4ef8-9247-77787a2b9727.png#averageHue=%23fafafa&clientId=ub956d6fd-3a0a-4&from=paste&id=u07465dc5&originHeight=420&originWidth=707&originalType=url&ratio=0.800000011920929&rotation=0&showTitle=false&status=done&style=none&taskId=udb47fdd1-8349-4191-a419-f0eba3b1d96&title=)

<a name="UlKiY"></a>

## 为什么需要头部压缩？

<br />假定一个页面有 100 个资源需要加载（这个数量对于今天的 Web 而言还是挺保守的）, 而每一次请求都有 1kb 的消息头（这同样也并不少见，因为 Cookie 和引用等东西的存在）, 则至少需要多消耗 100kb 来获取这些消息头。HTTP2.0 可以维护一个字典，差量更新 HTTP 头部，大大降低因头部传输产生的流量。具体参考：HTTP/2 头部压缩技术介绍

<a name="bPyqE"></a>

## HTTP2.0 多路复用有多好？

<br />HTTP 性能优化的关键并不在于高带宽，而是低延迟。TCP 连接会随着时间进行自我「调谐」，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 TCP 慢启动。由于这种原因，让原本就具有突发性和短时性的 HTTP 连接变的十分低效。<br />HTTP/2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升。
